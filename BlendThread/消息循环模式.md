# 消息循环模式（RunLoop Mode）

**消息循环模式**是 RunLoop 在特定场景下的事件过滤机制。它让 RunLoop 在不同的场景下只处理特定类型的事件，从而避免不必要的干扰。

## 一、什么是 Mode？

一个 **Mode** 是一组 **输入源（Input Sources）**、**定时器（Timers）** 和 **观察者（Observers）** 的集合。RunLoop 在特定时间只能在一个 Mode 下运行，只处理该 Mode 下的事件源。

### 核心概念：
```
┌─────────────────────────────────────┐
│           一个 RunLoop               │
├─────────────────────────────────────┤
│ 包含多个 Mode，但每次只在一个 Mode 中运行 │
└─────────────────────────────────────┘
    ├── Mode 1 (例如：Default)
    │     ├── Source A
    │     ├── Timer B
    │     └── Observer C
    │
    ├── Mode 2 (例如：Tracking)
    │     ├── Source D
    │     ├── Timer E
    │     └── Observer F
    │
    └── Mode 3 (例如：Common [虚拟])
```

## 二、iOS 中的主要 Mode

### 1. **NSDefaultRunLoopMode（默认模式）**
```swift
// 大多数情况下运行在此模式
// 除了界面跟踪外的大部分操作
RunLoop.current.currentMode == .default
```

### 2. **UITrackingRunLoopMode（界面跟踪模式）**
```swift
// 当用户交互时切换到此模式
// 例如：UIScrollView 滚动时
RunLoop.current.currentMode == .tracking
```

### 3. **UIInitializationRunLoopMode（应用启动模式）**
```objc
// 应用启动时的模式
// 启动完成后不再使用
```

### 4. **NSRunLoopCommonModes（通用模式）**
```swift
// 这是一个"伪模式"，是一个 Mode 的集合
// 包含 .default 和 .tracking
// 添加到 CommonModes 的事件会在所有常用模式下执行
```

## 三、Mode 切换的实际例子

### 场景：ScrollView 滚动时的 Mode 变化

```swift
class ViewController: UIViewController, UIScrollViewDelegate {
    let timer1 = Timer(timeInterval: 1.0, repeats: true) { _ in
        print("Timer 1 - Default Mode")
    }
    
    let timer2 = Timer(timeInterval: 1.0, repeats: true) { _ in
        print("Timer 2 - Common Mode")
    }
    
    override func viewDidLoad() {
        super.viewDidLoad()
        
        // Timer 1: 只在 Default Mode 下执行
        RunLoop.current.add(timer1, forMode: .default)
        
        // Timer 2: 在 CommonModes 下执行（包括 Default 和 Tracking）
        RunLoop.current.add(timer2, forMode: .common)
        
        // 创建一个 ScrollView 来观察模式切换
        let scrollView = UIScrollView(frame: view.bounds)
        scrollView.contentSize = CGSize(width: view.bounds.width, 
                                       height: view.bounds.height * 2)
        scrollView.delegate = self
        view.addSubview(scrollView)
    }
    
    func scrollViewDidScroll(_ scrollView: UIScrollView) {
        // 滚动时：
        // Timer 1 停止（因为不在 Default Mode）
        // Timer 2 继续执行（因为 CommonModes 包含 Tracking Mode）
        let currentMode = RunLoop.current.currentMode
        print("当前 Mode: \(currentMode?.rawValue ?? "unknown")")
    }
}
```

**输出结果：**
```
静止时：
Timer 1 - Default Mode
Timer 2 - Common Mode

滚动时：
当前 Mode: UITrackingRunLoopMode
Timer 2 - Common Mode  # Timer 1 停止输出！
```

## 四、不同 Mode 的特性对比

| Mode | 使用场景 | 是否响应触摸 | 是否响应定时器（普通） | 备注 |
|------|---------|------------|-------------------|------|
| **Default** | 空闲状态 | ✅ | ✅ | 应用空闲时的默认状态 |
| **Tracking** | 滚动/拖拽时 | ✅ | ❌ | 保证滑动流畅性 |
| **Common** | 所有常见场景 | ✅ | ✅ | 虚拟集合，非实际 Mode |

## 五、Mode 的工作原理

### 1. **Mode 结构**
```objc
struct __CFRunLoopMode {
    CFStringRef _name;                    // Mode 名称
    CFMutableSetRef _sources0;           // 非端口事件源
    CFMutableSetRef _sources1;           // 端口事件源
    CFMutableArrayRef _observers;        // 观察者
    CFMutableArrayRef _timers;           // 定时器
};
```

### 2. **RunLoop 与 Mode 的关系**
```objc
struct __CFRunLoop {
    CFMutableSetRef _commonModes;        // 标记为 Common 的 Mode 集合
    CFMutableSetRef _commonModeItems;    // 所有 Common Items
    CFRunLoopModeRef _currentMode;       // 当前运行的 Mode
    CFMutableSetRef _modes;              // 所有 Mode 的集合
};
```

## 六、实际开发中的应用

### 1. **定时器在滚动时不暂停**
```swift
// 方法1：使用 CommonModes
let timer = Timer(timeInterval: 1.0, repeats: true) { _ in
    print("这个定时器滚动时也执行")
}
RunLoop.current.add(timer, forMode: .common)

// 方法2：使用 GCD 定时器（不受 RunLoop Mode 影响）
var gcdTimer: DispatchSourceTimer?
func startGCDTimer() {
    let queue = DispatchQueue.main
    gcdTimer = DispatchSource.makeTimerSource(queue: queue)
    gcdTimer?.schedule(deadline: .now(), repeating: 1.0)
    gcdTimer?.setEventHandler { [weak self] in
        print("GCD 定时器 - 不受 Mode 影响")
    }
    gcdTimer?.resume()
}
```

### 2. **特定时机执行任务**
```swift
// 只在滑动结束后执行
func performAfterScrolling() {
    // 添加到 Default Mode，滚动时不执行
    perform(#selector(updateUI), 
           with: nil, 
           afterDelay: 0, 
           inModes: [.default])
}

@objc func updateUI() {
    print("滚动结束，更新UI")
}
```

### 3. **监听 Mode 变化**
```objc
// 添加 RunLoop 观察者
CFRunLoopObserverRef observer = CFRunLoopObserverCreateWithHandler(
    kCFAllocatorDefault,
    kCFRunLoopEntry | kCFRunLoopExit,  // 观察进入和退出
    true,                              // 是否重复观察
    0,                                 // 优先级
    ^(CFRunLoopObserverRef observer, CFRunLoopActivity activity) {
        if (activity == kCFRunLoopEntry) {
            NSLog(@"进入 Mode: %@", CFRunLoopCopyCurrentMode(CFRunLoopGetCurrent()));
        } else if (activity == kCFRunLoopExit) {
            NSLog(@"退出 Mode");
        }
    }
);

CFRunLoopAddObserver(CFRunLoopGetMain(), observer, kCFRunLoopCommonModes);
```

## 七、自定义 Mode

```swift
// 创建自定义 Mode
let customMode = RunLoop.Mode("com.example.customMode")

// 在自定义 Mode 中执行任务
RunLoop.current.perform(in: customMode) {
    print("在自定义 Mode 中执行")
}

// 注意：自定义 Mode 需要手动切换，不会自动触发
```

## 八、常见问题与解决方案

### 问题1：定时器在 TableView 滚动时停止
```swift
// ❌ 错误做法
Timer.scheduledTimer(withTimeInterval: 1.0, repeats: true) { _ in
    // 滚动时停止
}

// ✅ 正确做法
let timer = Timer(timeInterval: 1.0, repeats: true) { _ in
    // 滚动时也执行
}
RunLoop.current.add(timer, forMode: .common)
```

### 问题2：滚动时网络请求回调延迟
```swift
// 网络请求完成后的回调默认在 Default Mode
URLSession.shared.dataTask(with: url) { data, response, error in
    DispatchQueue.main.async {
        // 如果正在滚动，更新会被延迟
        self.updateUI(data)
    }
}

// 优化：明确指定 Mode
URLSession.shared.dataTask(with: url) { data, response, error in
    DispatchQueue.main.async {
        // 立即执行，不受 Mode 影响
        CFRunLoopPerformBlock(CFRunLoopGetMain(), CFRunLoopMode.defaultMode.rawValue) {
            self.updateUI(data)
        }
        CFRunLoopWakeUp(CFRunLoopGetMain())
    }
}
```

## 总结

**消息循环模式的核心价值**：
1. **事件隔离**：不同场景下只处理相关事件
2. **性能优化**：滑动时暂停非必要任务保证流畅性
3. **优先级控制**：重要事件优先处理
4. **资源管理**：避免事件冲突和资源浪费

理解 Mode 机制对于开发高性能、流畅的 iOS 应用至关重要。正确使用 Mode 可以避免很多界面卡顿和响应问题。