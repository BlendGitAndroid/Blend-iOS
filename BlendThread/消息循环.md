在 iOS 中，**消息循环**（Message Loop）通常指的是 **RunLoop**，它是 iOS 应用事件处理机制的核心组件之一。

## 一、什么是 RunLoop？

RunLoop 是 iOS/macOS 开发中的一个基本概念，它是：
- **一个事件处理循环**，用于调度任务和处理事件
- **一种让线程能随时处理事件但并不退出的机制**
- 苹果基于 `CFRunLoop` 的实现，为每个线程提供的事件循环

## 二、RunLoop 的核心作用

### 1. **保持线程存活**
```objc
// 没有 RunLoop 的线程执行完任务就结束
NSThread *thread = [[NSThread alloc] initWithTarget:self 
                                           selector:@selector(task) 
                                             object:nil];
[thread start]; // 执行完 task 后线程立即结束

// 有 RunLoop 的线程可以持续工作
- (void)runThread {
    @autoreleasepool {
        NSRunLoop *runLoop = [NSRunLoop currentRunLoop];
        [runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode];
        [runLoop run]; // 线程进入循环，保持活跃
    }
}
```

### 2. **事件处理**
- 触摸事件（UITouch）
- 定时器（NSTimer）
- 网络请求回调
- 界面刷新（UI 更新）

### 3. **节省 CPU 资源**
- 当没有事件时，线程进入休眠状态
- 有事件时，立即唤醒处理

## 三、RunLoop 的基本结构

```
┌─────────────────────────────────┐
│           RunLoop 运行           │
├─────────────────────────────────┤
│   等待消息 ──→ 处理消息 ──→ 休眠   │
└─────────────────────────────────┘
         ↑           ↑
     事件到达    处理完成
```

### RunLoop 的 Mode（模式）
```objc
NSDefaultRunLoopMode    // 默认模式，大多数操作在此模式下
UITrackingRunLoopMode   // 界面跟踪模式（如 UIScrollView 滑动时）
NSRunLoopCommonModes    // 通用模式，包含以上两种
```

## 四、RunLoop 的实际应用

### 1. **定时器的正确使用**
```swift
// 错误：滑动时定时器会暂停
let timer = Timer.scheduledTimer(timeInterval: 1.0, 
                                target: self, 
                                selector: #selector(tick), 
                                userInfo: nil, 
                                repeats: true)

// 正确：滑动时也能正常计时
let timer = Timer(timeInterval: 1.0, 
                 repeats: true) { _ in
    print("tick")
}
RunLoop.current.add(timer, forMode: .common)
```

### 2. **性能优化**
```swift
// 在特定模式下执行任务，避免影响滚动流畅性
DispatchQueue.main.async {
    // 默认在 NSDefaultRunLoopMode 执行
    self.updateUI()
}

// 可以在滑动结束后更新
self.perform(#selector(updateAfterScroll), 
            with: nil, 
            afterDelay: 0, 
            inModes: [.default])
```

### 3. **常驻线程**
```swift
class PermanentThread {
    private var thread: Thread?
    
    func start() {
        thread = Thread {
            // 添加 Port 让 RunLoop 有事可做，防止退出
            RunLoop.current.add(Port(), forMode: .default)
            RunLoop.current.run()
        }
        thread?.start()
    }
}
```

## 五、主线程的 RunLoop

iOS 应用启动时，主线程的 RunLoop 自动创建并运行：

```objc
// UIApplicationMain 函数内部
int main(int argc, char * argv[]) {
    @autoreleasepool {
        return UIApplicationMain(argc, argv, nil, 
                               NSStringFromClass([AppDelegate class]));
    }
}

// UIApplicationMain 实际上启动了主线程的 RunLoop
```

## 六、RunLoop 的事件源

RunLoop 监控两种事件源：

1. **Input Sources（输入源）**
   - Port-based sources（基于端口的）
   - Custom sources（自定义的）

2. **Timer Sources（定时器源）**
   - 预定时间的同步事件

## 七、RunLoop 与 AutoreleasePool

RunLoop 在每个循环迭代中：
1. 创建自动释放池
2. 处理事件
3. 销毁自动释放池，释放对象

## 总结

**RunLoop 是 iOS 应用的"心脏"**：
- ✅ **管理事件/消息**：有序处理触摸、定时器等
- ✅ **线程管理**：决定线程何时工作、何时休眠
- ✅ **性能优化**：避免资源浪费，提高响应速度
- ✅ **定时器协调**：确保定时器在正确时机触发

理解 RunLoop 对于解决界面卡顿、优化性能、实现后台常驻线程等问题至关重要。它是 iOS 开发中底层但非常实用的知识点。