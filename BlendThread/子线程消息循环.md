# 子线程消息循环详解

## 一、主线程 vs 子线程的 RunLoop

### 1. **默认行为差异**
```objc
// 主线程：RunLoop 自动创建并运行
int main(int argc, char * argv[]) {
    @autoreleasepool {
        // UIApplicationMain 内部会启动主线程的 RunLoop
        return UIApplicationMain(argc, argv, nil, 
                               NSStringFromClass([AppDelegate class]));
    }
}

// 子线程：RunLoop 不会自动启动
dispatch_async(dispatch_get_global_queue(0, 0), ^{
    // 此时子线程没有 RunLoop
    NSLog(@"子线程执行任务");
    // 执行完毕后线程立即结束
});
```

### 2. **为什么有这个差异？**
- **主线程**需要持续处理 UI 事件、触摸、定时器等，必须保持活跃
- **子线程**通常执行一次性任务，执行完毕即可销毁，不需要额外开销

## 二、启动子线程的 RunLoop

### 基本方法
```objc
- (void)startThread {
    NSThread *thread = [[NSThread alloc] initWithTarget:self 
                                               selector:@selector(threadEntry) 
                                                 object:nil];
    [thread start];
}

- (void)threadEntry {
    @autoreleasepool {
        // 1. 获取当前线程的 RunLoop（首次调用时创建）
        NSRunLoop *runLoop = [NSRunLoop currentRunLoop];
        
        // 2. 添加一个 Input Source（否则 RunLoop 会立即退出）
        [runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode];
        
        // 3. 启动 RunLoop
        [runLoop run];  // 这会阻塞当前线程
        
        // 注意：run 方法不会返回，后面的代码不会执行
        NSLog(@"这行代码永远不会执行");
    }
}
```

### RunLoop 的启动模式
```objc
// 不同的启动方法
NSRunLoop *runLoop = [NSRunLoop currentRunLoop];

// 方法1：无限运行，直到手动停止（很难停止）
[runLoop run];

// 方法2：运行到指定时间
[runLoop runUntilDate:[NSDate dateWithTimeIntervalSinceNow:10]];

// 方法3：运行指定时间，期间处理事件
[runLoop runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];
```

## 三、线程池的实现原理

### 1. **核心思想：线程复用**
```objc
// 线程池伪代码
@interface ThreadPool : NSObject
@property (nonatomic, strong) NSMutableArray<NSThread *> *idleThreads;
@property (nonatomic, strong) NSMutableArray<NSThread *> *busyThreads;
@end

@implementation ThreadPool

- (void)setup {
    // 创建固定数量的线程并保持活跃
    for (int i = 0; i < 5; i++) {
        NSThread *thread = [[NSThread alloc] initWithTarget:self 
                                                   selector:@selector(threadMain) 
                                                     object:nil];
        [thread start];
        [self.idleThreads addObject:thread];
    }
}

- (void)threadMain {
    @autoreleasepool {
        // 启动 RunLoop 保持线程存活
        NSRunLoop *runLoop = [NSRunLoop currentRunLoop];
        [runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode];
        [runLoop run];  // 线程永不退出
    }
}

@end
```

### 2. **执行任务：performSelector**
```objc
// 让常驻线程执行任务
- (void)executeTask:(id)task onThread:(NSThread *)thread {
    // 在指定线程上执行方法
    [self performSelector:@selector(handleTask:) 
                 onThread:thread 
               withObject:task 
            waitUntilDone:NO];
}

- (void)handleTask:(id)task {
    // 这个方法的代码会在指定的子线程上执行
    NSLog(@"在当前线程执行任务：%@", [NSThread currentThread]);
    
    // 处理任务...
    
    // 任务完成后，线程不会销毁，继续等待下一个任务
}
```

### 3. **完整的线程池示例**
```objc
@interface PermanentThread : NSObject
@property (nonatomic, strong) NSThread *innerThread;
@end

@implementation PermanentThread

// 创建线程并启动 RunLoop
- (instancetype)init {
    if (self = [super init]) {
        self.innerThread = [[NSThread alloc] initWithBlock:^{
            // 创建 RunLoop
            NSRunLoop *runLoop = [NSRunLoop currentRunLoop];
            
            // 添加 Source 防止退出
            NSPort *port = [NSPort port];
            [runLoop addPort:port forMode:NSDefaultRunLoopMode];
            
            // 运行 RunLoop
            [runLoop run];
            
            NSLog(@"RunLoop 结束"); // 实际不会执行
        }];
        [self.innerThread start];
    }
    return self;
}

// 执行任务
- (void)executeTask:(void (^)(void))task {
    if (!self.innerThread || !task) return;
    
    [self performSelector:@selector(__executeTask:) 
                 onThread:self.innerThread 
               withObject:task 
            waitUntilDone:NO];
}

- (void)__executeTask:(void (^)(void))task {
    task();
}

// 停止线程
- (void)stop {
    if (!self.innerThread) return;
    
    [self performSelector:@selector(__stop) 
                 onThread:self.innerThread 
               withObject:nil 
            waitUntilDone:YES];
}

- (void)__stop {
    // 停止 RunLoop
    CFRunLoopStop(CFRunLoopGetCurrent());
    self.innerThread = nil;
}

@end
```

## 四、实际应用场景

### 1. **后台下载任务**
```objc
// 创建下载专用线程
- (void)setupDownloadThread {
    self.downloadThread = [[NSThread alloc] initWithTarget:self 
                                                  selector:@selector(downloadThreadEntry) 
                                                    object:nil];
    [self.downloadThread start];
}

- (void)downloadThreadEntry {
    @autoreleasepool {
        NSRunLoop *runLoop = [NSRunLoop currentRunLoop];
        [runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode];
        [runLoop run];
    }
}

// 执行下载任务
- (void)downloadFile:(NSString *)url {
    [self performSelector:@selector(performDownload:) 
                 onThread:self.downloadThread 
               withObject:url 
            waitUntilDone:NO];
}
```

### 2. **数据库操作线程**
```objc
// 单例数据库线程
+ (instancetype)shared {
    static DatabaseManager *instance = nil;
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        instance = [[self alloc] init];
        [instance setupDatabaseThread];
    });
    return instance;
}

- (void)setupDatabaseThread {
    self.dbThread = [[NSThread alloc] initWithBlock:^{
        @autoreleasepool {
            // 初始化数据库连接
            self.database = [FMDatabase databaseWithPath:dbPath];
            
            NSRunLoop *runLoop = [NSRunLoop currentRunLoop];
            [runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode];
            [runLoop run];
        }
    }];
    [self.dbThread start];
}
```

## 五、注意事项

### 1. **内存管理**
```objc
- (void)dealloc {
    // 必须停止 RunLoop，否则线程不会释放
    [self stop];
}
```

### 2. **避免死锁**
```objc
// 错误示例：在 waitUntilDone:YES 时可能死锁
[self performSelector:@selector(task) 
             onThread:thread 
           withObject:nil 
        waitUntilDone:YES];  // 小心使用！

// 正确：使用异步方式
[self performSelector:@selector(task) 
             onThread:thread 
           withObject:nil 
        waitUntilDone:NO];
```

### 3. **RunLoop 停止技巧**
```objc
// 使用自定义 Input Source 控制 RunLoop
- (void)threadEntry {
    while (!self.shouldExit) {
        @autoreleasepool {
            // 运行一段时间，然后检查退出标志
            NSRunLoop *runLoop = [NSRunLoop currentRunLoop];
            [runLoop runMode:NSDefaultRunLoopMode 
                  beforeDate:[NSDate dateWithTimeIntervalSinceNow:1.0]];
        }
    }
}
```

## 总结

1. **子线程 RunLoop 需要手动启动**，默认不开启
2. **线程常驻的关键**是启动 RunLoop 并添加 Input Source
3. **线程池通过 RunLoop 实现线程复用**，避免频繁创建销毁
4. **使用 performSelector:onThread:** 在指定线程执行任务
5. **合理管理 RunLoop 生命周期**，避免内存泄漏

这种模式适用于需要后台持续处理任务、数据库操作、文件下载等需要线程复用的场景，能显著提升性能并减少资源开销。