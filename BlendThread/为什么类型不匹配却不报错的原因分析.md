### 为什么类型不匹配却不报错的原因分析

在 `HMDownloaderOperation` 中，虽然 `finishedBlock` 定义为接收 `UIImage` 类型参数，但实际传递 `NSString` 类型却能正常编译和运行，这涉及到 Objective-C 的几个特性：

#### 编译不报错的原因

1. **Objective-C 的动态类型特性**
   - Objective-C 是动态类型语言，编译时的类型检查相对宽松
   - 当参数类型不匹配时，编译器通常只会发出警告而非错误
   - 这里可能是因为项目的警告级别设置较低，或者警告被忽略了

2. **Block 的参数类型检查**
   - Block 的参数类型在编译时会进行检查，但这种检查不是强制性的
   - 编译器会生成类型转换代码，尝试将传递的参数转换为 Block 期望的类型

#### 运行不报错的原因

1. **参数未被实际使用**
   - 在 `ViewController` 的回调中，虽然参数类型声明为 `UIImage *img`，但实际上没有使用这个参数
   - 代码中只是打印了线程信息，没有访问 `img` 的任何属性或方法

2. **消息发送机制**
   - Objective-C 使用动态消息发送机制，只有在实际调用方法时才会检查对象是否响应
   - 由于没有调用 `img` 的任何方法，所以即使传递了错误类型也不会崩溃

3. **指针本质**
   - 在 64 位系统中，所有对象指针大小相同（8字节）
   - 无论传递 `NSString` 还是 `UIImage`，本质上都是传递一个指针地址
   - 只要不通过这个指针调用不存在的方法，就不会有运行时错误

#### 技术原理总结

这种现象体现了 Objective-C 的灵活性和动态性：

- **编译时**：类型检查宽松，允许不同类型之间的赋值和传递
- **运行时**：基于消息发送机制，只有实际使用对象时才会检查其能力
- **指针统一性**：所有对象指针大小相同，为类型转换提供了基础

#### 潜在风险

虽然当前代码能正常运行，但这种做法存在潜在风险：

1. **可读性差**：代码意图不明确，容易让其他开发者误解
2. **维护困难**：后续修改时可能忘记类型不匹配的问题
3. **潜在崩溃**：如果将来在回调中使用 `img` 的任何 `UIImage` 特有方法，会导致运行时崩溃

#### 最佳实践

正确的做法应该是：
1. 保持类型一致，要么都使用 `UIImage`，要么都使用 `NSString`
2. 如果需要传递不同类型，应使用 `id` 类型并在使用时进行类型检查
3. 添加适当的注释说明类型转换的原因

**总结**：这种类型不匹配却能运行的情况，是 Objective-C 动态特性的体现，但不推荐在实际项目中使用，因为它降低了代码的可靠性和可维护性。