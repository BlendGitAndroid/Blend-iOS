/*

 1. 基本概念.
 
    0b10011001  1 * (2的0次方)
    1890123
 
    数码: 指的是这个数据的每一位的数字.
    数位: 数码在这个数中的位置.从右到左.依次递增 从0开始.
    基数: 就是每一个数码可以有多少个数据来表示.
          基数其实指的就是这个数的进制.
    位权: 数码 乘以 (基数的数位次方)
            任何数的0次方都为1.
 
 
 2. 十进制转换为二进制.
    
    除2取余法. 将这个数除以2. 直到商为1或者0. 然后最后1个商和所有余数倒序. 就是这个十进制对应的二进制.
 
    10  1010
    178 10110010
 
 
 3. 二进制转换为十进制.
    加权法. 将这个二进制数的每个数码的位权相加,就是这个二进制对应的十进制.
 
    10101  每1个数码的位权相加.
    第0位的位权: 1 * 2的0次方   1
      1        0
      2        4
      3         0
      4        16
 
     21
 
    二进制的位权:假如每1个数码都是
    0    1
    1    2
    2    4
    3    8
    4    16
    5    32
    6    64
 
 4. 十进制转换为八进制.
 
    除8取余
 
    78
 
 
 5. 八进制转换为十进制
 
    加权法. 将八进制的每1个数码的位权相加 得到的就是其对应的十进制数.
 
    0342
 
    第0位: 2 * 8的0次方  2
      1   4 * 8的1      32
      2   3 * 8的2   192
 
    226
 
 
 6. 二进制转换为八进制.
 
    三合一法则. 将这个二进制从低位到高位每三位分成1组.高位不够补0
              将每1组转换为十进制.
              将每1组的十进制连起来. 就是这个二进制对应的八进制.
 
 
    001 011 100 110 011
    1    3   4   6   3
 
 
 7. 八进制转换为二进制.
 
    一拆三. 将这个八进制数的没1个数码拆为1个三位的二进制数.把这些二进制数连起来.
 
    134674
    001 011 100 110 111 100
 
 
 8. 二进制转换为十六进制.
    
    四合一 法则. 将这个二进制从低位到高位每四位分成1组.高位不够补0
               将每1组转换为对应的十六进制.
               将每1组转换成功的十六进制数链接起来.
 
    
    11100101010111110111101010101
 
    0001 1100 1010 1011 1110 1111 0101 0101
       1  c    a    b    e     f   5    5

 
 9. 十六进制转换为二进制.
 
    一拆四法则:  将这个十六进制的书的每1个数码拆为1个四位的二进制数,将其连起来.
 
    4dea761;
 
    0100 1101 1110 1010 0111 0110 0001
 
    10  20 16+4
 
    二进制全都是1的情况
    0    1
    1    2
    2    4
    3    8
 
    1010
 
 
   10100
 
 
 
 
 
 
 
 */

#include <stdio.h>

int main(int argc, const char * argv[])
{
    
    int num = 0b0100110111101010011101100001;
    printf("%x\n",num);
    return 0;
}
