/*
 1. 变量在内存中的存储方式.
 
    1). 不同类型的变量在内存中占据不同的字节数.
        1个变量占用的字节一定是连续的.
 
        int 4
        double 8
        float 4
        char 1
 
    2). 在为变量分配字节空间的时候,是从高地址向低地址分配的连续空间.
        先声明的变量是在高字节. 后声明的变量是在低字节.
 
 
    3). 任何数据在内存中都是以其二进制的补码存储的.
        低位存储在低字节.高位存储在高字节.
 
 
    4). 每1个字节在内存中都有1个地址. 十六进制数.
        变量的地址:是组成这个变量的低字节的地址.
 
 
    5). 使用&取地址运算符可以直接拿到变量的地址.
 
 
    6). 使用%p打印地址类型的数据.
 
 
 2. 数组在内存中是如何存储的呢?
 
    int arr[3];
 
    1). 声明1个数组,
        在内存中从高字节向低字节申请连续的 (数组的长度 * 每1个元素的字节数) 个字节的空间.
 
 
    2). 下标为0的元素在低字节.
 
    
    3). 元素的值还是按照之前那样 存储的是 数据的二进制的补码.
 
    
    4). 数组的元素的本质就是1个普通类型的变量.
        1个数组就是由多个普通类型的变量联合而成的.
 
        每1个元素就是1个普通变量.所以没1个元素也有自己的地址.
 
 
 3. 数组的地址.
 
    1). 数组的地址是数组中最低字节的地址.
 
    2). 数组的地址是数组中下标为0的元素的地址.
 
    3). 数组的地址是数组中下标为0的元素的低字节的地址.
 
 
    4). 重点:
        数组名就代表数组的地址.
        C语言的数组名中存储的是数组的地址.
        所以.我们不能直接打印数组名,这样得不到数组的元素的值,因为数组名中存储的是数组的地址.
        所以我们应该使用 %p 来打印数组名.
 
 
    
    数组的地址 == 数组名 == 数组中的低字节的地址 == 数组中下标为0的元素的地址 == 数组中下标为0的元素的低字节的地址.
 
 
    
 
 4. 数组的长度计算.
 
    1). 数组的每一个元素的类型相同.所以数组的每一个元素占用的字节空间一样.
 
    2). 使用sizeof运算符 可以计算 数组总共占用的字节数.
 
        sizeof(数组名); 就可以得到这个数组占用的总的字节数.
 
    3). 得到数组占用的总的字节数以后,那么就可以用总的字节数除以每1个元素占用的字节数.
        就可以得到数组的长度.
 
 
        sizeof(数组名) / 每1个元素的字节数. 就可以得到数组的长度.
    
 
    4). 不建议将字节数写死. 元素占用的字节数建议也是使用sizeof计算出来. 因为不同的系统不同的编译器
        相同的变量可能占用的字节不一样.

        sizeof(arr) / sizeof(元素类型);
 
        sizeof(arr) / sizeof(arr[0]);
 
 
 
 
 
 
 
 
 */

#include <stdio.h>

int main(int argc, const char * argv[])
{
    
//    int arr[] = {1,21,3,24,3,54,6,456,32,4,345,3,5,46,5,7,8,77,64,3,42};
//    int *p1 = arr;
//    int len =  sizeof(p1);
//    printf("len = %d\n",len);
    

//    
//    for(int i = 0; i < len ; i++)
//    {
//        printf("arr[%d] = %d\n",i,arr[i]);
//    }
    
    //printf("len = %d\n",len);
    
    
    
    
    
//    int arr[3];
//    arr[0] = 10;
//    arr[1] = 11;
//    arr[2] = 12;
//    
//    
//    
//    printf("数组的地址是下标为0的元素的地址: %p\n",&arr[0]);
//    
//    
//    printf("arr = %p\n",arr);
//    
    
    
    
    return 0;
}
