/*
 1. 函数的参数.
    为函数传参的过程就是1个赋值的过程.
    是将实参赋值给形参.
 
 
 2. 当参数的类型是int、double、float、char类型的时候.
    调用者传入1个实参变量.
    函数执行完毕之后,对实参变量的值没有影响.
 
    像这样的传递我们叫做值传递.
    调用者将实参变量传递到给函数.不管函数内部是如何操作形参.
    对实参变量没有任何影响.
 
 3. 当1个函数的参数是1个普通变量的时候.那么这个时候可以传递数组的元素(数组的元素的类型和参数的类型一致).
 
 
 
 4. 数组是否可以作为函数的参数呢?
    
    肯定可以. 因为数组也是1个数据类型.
 
    1). 声明:
        直接在函数的小括弧中声明1个数组就可以了.
        void testArray(int arr[3]);
 
    2). 调用
        如果被调用的函数带了参数 并且参数的类型是1个数组.
        那么在调用的时候,你必须也要为其传递1个数组.并且传递的数组的类型还要和参数数组的类型一致.
 
 
    3). 遇到的问题.
 
        在函数的内部,通过sizeof去计算 [参数数组] 占用的字节数的时候.
        我们发现1个奇怪的问题:无论参数数组的长度声明为多大,得到的永远都是8个字节.
 
        这个时候,通过sizeof去计算参数 数组的长度的时候,是算不出来的.
        为什么?
 
        当数组作为函数的参数的时候.那么在传递的时候,会丢失数组的长度.
 
        结论: 当数组作为函数的参数的时候.
             在函数的内部使用sizeof计算参数数组的字节数,
             永远得到的都是8
 
             所以,在函数内部无法使用sizeof计算参数数组的长度.
 
 
    4). 为什么?
 
       1). 如果函数的参数是1个数组,在声明这个参数的时候,并不会去真正创建数组.
           而是去声明1个用来存储数组地址的1个指针变量.
           这个指针变量在内存中占据8个字节.
           所以,你通过sizeof去计算参数数组的字节的时候 得到的都是8
 
       2). 在传值的时候.是把实参数组名传递进来.
           数组名代表数组的地址.
           所以,这个时候传值 传的是数组的地址.
           把数组的地址传递给了函数的参数.
           所以,函数的参数也指向了实参数组.
 
 
    5). 如何解决.
 
        那么就让调用者将实参数组的长度传递给我.
        再写1个参数.让调用者将传递进来的数组的出长度告诉我,
        函数就不要去算了. 算也算不出来.
 
        注意: 
        如果我们的函数的参数是1个数组. 这个时候还必须得加1个参数. 让调用者将这个数组的长度传递进来.
 
 
    6). 当数组作为函数的参数的时候.实际上他并不是1个数组.而是1个用来存储数组地址的个指针变量.
        所以,数组作为函数的参数的时候.那个长度就没有必要写了.
 
    
 5. 当函数的参数是1个数组的时候.
    那么在传递的时候,传递的是实参数组的地址.
    所以,形参数组指针指向了实参数组.
 
    这个时候通过形参数组指针操作数组 实际上操作的就是是实参数组.
 
    这种参数传递 我们就叫做地址传递.
    目前为止 只有数组是这么1个特性.
 
 
 6. 重要的结论
    1). 当数组作为函数的参数的时候. 会丢失数组的长度.
        所以,这个时候还需要1个参数 让调用者将传入的数组的长度传进来.
 
    2). 当数组作为函数的参数的时候.
        在函数的内部去修改这个参数数组的元素,
        其实修改的就是实参数组的元素
 
    3). 强调:只有数组作为函数的参数的时候,通过sizeof才算不出来长度.
 
    
 
 
 
 
 
 
 
 */

#include <stdio.h>

void test(int num);
void test2(char ch);



//如何把数组作为函数的参数.
void testArray(int arr[],int len)
{
   //int i =    sizeof(arr);
   // printf("len = %d\n",len);
    for(int i = 0; i < len; i++)
    {
        printf("%d\n",arr[i]);
    }
}


void test3(int arr[],int len)
{
    for(int i = 0; i < len; i++)
    {
        arr[i] = 100;
    }
    
}

//写1个函数,为这个函数传递1个数组,函数内部为这个数组的每一个元素+2;
void test4(int arr[],int len)
{
    for(int i =0; i < len; i++)
    {
        arr[i] += 2;
    }
}




int main(int argc, const char * argv[])
{
    int arr[] = {10,20,30,4,50,4,5034,530,5,403};
    
    test4(arr, sizeof(arr)/sizeof(arr[0]));
    
    
    for(int i = 0; i < sizeof(arr)/sizeof(arr[0]);i++)
    {
        printf("%d\n",arr[i]);
    }
    
    
    
    
    
//    int shuZu[] = {110,20,305};
//    
//    test3(shuZu, sizeof(shuZu)/sizeof(shuZu[0]));
//    
//    for(int i = 0; i < 3; i++)
//    {
//        printf("%d\n",shuZu[i]);
//    }
    
    
    
    
    
    //testArray(shuZu,3);
    
    
    
    
//    int arr[] = {10,20,30};
//    
//    test(arr[0]);
//    
//    printf("arr[0] = %d\n",arr[0]);
    
//    int num = 100;
//    test(num);
//    printf("num = %d\n",num);
    
//    char ch = 'a';
//    test2(ch);
//    printf("ch = %c\n",ch);
    
    return 0;
}

void test2(char ch)
{
    ch = 'x';
}


void test(int num)
{
    num++;
    num++;
    num++;
}