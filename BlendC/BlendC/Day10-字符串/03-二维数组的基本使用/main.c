/*
 1. 思考一个问题
 
    某公司 有3个销售小组.每1组有4个人.
    将上个月的每一个人的销售成绩保存起来.
 
    1). 声明12个变量.
 
    2). 声明1个长度为12的数组.
        int chengJi[12];
 
        不好定位.第2组第2个人
 
    3). 声明3个长度为4的数组.
        int arr1[4];
        int arr2[4];
        int arr3[4];
 
    4). 如果自己不是1个程序,是公司的秘书.
        使用1个Excel表格来存储数据.
 
 
        使用Excel表格来保存数据的优点
        a. 相当直观.
        b. 方便定位数据.
 
 
 2. 天马行空.
 
    C语言中是否有像Excel那样的有行有列的表格结构的数据呢?
 
    可以不可以在内存中创建1个N行N列的1个表格.
 
    二维数组就是这样的1个东西.
 
    二维数组就是1个有行有列的1个表格.
 
    我们声明1个二维数组,就相当于在内存中创建了指定行指定列的1个表格来存储数据.
 
 
 
 3. 二维数组的声明.
 
    1). 二维数组首先是1个数组.所以它符合数组的特点
        a. 元素的类型相同.
        b. 存储的数据的个数固定.
        c. 方便管理数据.
 
    2). 二维数组的独有的特点:
 
        二维数组是1个有行有列的表格.
        使用单元格来存储数据.
        单元格就是二维数组的元素.
 
    3). 声明二维数组的语法.
 
        元素类型 数组名[行数][列数];
 
        int arr[3][4];
 
        表示在在内存中声明了1个二维数组,这个二维数组的名字叫做arr
        这个二维数组表示1个3行4列的表格.
        每1个单元格 就是这个二维数组的1个元素.
        每1个元素的类型是int
 
    4). 几个术语.
 
        a. 元素: 元素就是这个表格的每1个单元格. 所以二维数组真正存储数据的是表格中的每一个单元格.
        b. 下标: 元素的下标. 二维数组的每1个元素的下标有两个.
                1个是行下标 1个是列下标.
        c. 长度: 我们一般认为就是单元格的个数. 行 * 列
 
 
 4. 如何往二维数组中存储数据?
 
    1). 二维数组中真正存储数据的是表格中的每1个单元格.元素.
        所以,在存储数据的时候 必须要确定 到底要存储到哪1个元素之中.
 
        使用下标来确定二维数组中的元素. 二维数组的元素的下标有两个. 行下标 列下标.
 
        二维数组名[行下标][列下标] = 数据;
 
        int arr[3][4];
        arr[1][2] = 100;
        将100存储到arr数组的第1行的第2列的那个元素中.
 
 
    2). 为二维数组的元素赋值的数据的类型要和元素的类型一致   
        否则就会做自动类型转换.
 
 
    3). 行列下标请不要越界.
 
        否则就有可能会造成程序崩溃的问题.
 
 
 5. 如何从二维数组中取出数据
 
    1).二维数组中真正存储数据的是表格中的每1个单元格.元素.
       所以,你要取数据就要先确定到底要取那1个元素的数据.
       通过下标来确定. 而二维数组的元素的下标有2个.
 
       二维数组名[行下标][列下标];
 
 
    2).行列下标不要越界.
 
 
 
 6. 遍历二维数组的元素.
 
    for(int i = 0; i < 行数; i++)
    {
        for(int j = 0; j < 列数; j++)
        {
            arr[i][j];
        }
    }
 
 -------目前为止-------
 1. 二维数组是个什么东西?
 2. 声明
 3. 存储数据
 4. 取出数据和遍历.
 
 
 
 7. 使用二维数组要注意的地方.
 
    1). 关于二维数组的行数和列数
 
        a. 在声明二维数组的时候 必须要指定行数和列数.
        b. 并且这个行数和列数: 可以是变量、常量、宏、表达式.也可以是1也可以是0
           行数和列数不能是小数、负数.
 
 
    2). 关于二维数组的元素的默认值.
        如果我们声明1个二维数组 没有为这个二维数组的元素.
        这个二维数组的元素是有值的 值是1个垃圾值.
 
 
 8. 二维数组的元素的初始化.
 
    1). 全部初始化.  
        a. 先声明,再使用下标来初始化.
 
        b. 在声明的同时,就初始化数组的每一个元素. *****
             int arr[3][4] =
             {
                 {10,20,30,40},//第0行的数据
                 {50,60,70,80},//第1行的数据
                 {90,100,110,120}//第2行的数据.
             };
            里面的大括弧,就表示1行.
 
            10 20 30 40
            50 60 70 80
            90 100 110 120
 
        c. 上面这种方式初始化的时候.可以省略行数. ********
             int arr[][4] =
             {
                 {10,20,30,40},//第0行的数据
                 {50,60,70,80},//第1行的数据
                 {90,100,110,120}//第2行的数据.
             };
             根据大括弧的个数,编译器来自动确定行数.
 
    
        d. 直接省略里面的大括弧.编译器根据行数和列数自动判断哪些属于哪1行的.
           int arr[3][4] = {10,20,30,40,50,60,70,80,90,100,110,120};
 
 
        e. 上面的那种初始化方式 可以省略行数.编译器根据列数和数据的个数自动计算行数.
           int arr[][4] = {10,20,30,40,50,60,70,80,90,100,110,120};
 
    
    2). 部分初始化.
 
        a.  int arr[3][4] = {{10},{20},{30}};
            初始化指定行的数据. 那么其他的元素就会被自动初始化为0.
 
            10 0 0 0 
            20 0 0 0 
            30 0 0 0
 
        b.  int arr[3][4] = {10,20,30,40,50}; *****
            按照顺序去初始化每1个元素 其他的元素的值就会被自动初始化为0
            10 20 30 40 
            50 0  0  0 
            0  0  0  0
 
        c.  int arr[][4] = {10,20,30,40,50};
            省略行数,自动根据后面的元素的个数来计算行.
            其他的元素自动初始化为0 
            10 20 30 40 
            50 0  0  0
 
        d. int arr[3][4] = {[1]={10,20,30,40},[2]={50,60,70,80}};
           给指定的行初始化,其他的元素自动初始化为0
           0 0 0 0 
           10 20 30 40 
           50 60 70 80
 
        e. int arr[3][4] = {[0][1] = 20, [1][3] = 60};
            给指定的元素赋值.其他的元素自动初始化为0
            0 20 0 0 
            0 0  0 60
            0 0 0 0
 
 
 
 
 9. 案例. 
 
     某公司 有3个销售小组.每1组有4个人.
     将上个月的每一个人的销售成绩保存起来.
 
     1). 找出销售之王.
     2). 求每1组的平均销售成绩.
 
 
 
 10. 什么时候要使用二维数组?
 
     特点:有行有列的表格. 当你有类似于表格形状的数据的时候.就可以使用二维数组.
 
     5 10
 
 
     2D 地图的游戏.
 

 
 
 

 
 
 
 
 */

#include <stdio.h>
#define ROW 3
#define COL 4

int main(int argc, const char * argv[])
{
    
    int arr[3][4] =
    {
        {45,67,78,12},
        {78,14,56,15},
        {78,12,101,4}
    };
    
    
    int sum = 0;

    for(int i = 0; i < 3; i++)
    {
        for(int j = 0; j < 4; j++)
        {
            sum += arr[i][j];
        }
        printf("第%d组的平均销售成绩是:%d万\n",i+1,sum/4);
        sum = 0;
    }
    
    
    
//    int max = INT32_MIN;
//    
//    for(int i = 0; i < 3; i++)
//    {
//        for(int j = 0; j < 4; j++)
//        {
//            if(arr[i][j] > max)
//            {
//                max = arr[i][j];
//            }
//        }
//    }
//    
//    printf("销售之王的销售成绩是:%d万\n",max);
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    //int arr[][4] = {10,20,30,40,50,60,70,80,90,100,110,120};
//    
//    int arr[][4] =
//    {
//        {10,20,30,40},//第0行的数据
//        {50,60,70,80},//第1行的数据
//        {90,100,110,120}//第2行的数据.
//    };
//    
    
//    int row = 3;
//    int col = 4;
//    int arr[3][4];
//    
//    arr[0][0] = 10;
//    arr[0][1] = 20;
//    arr[0][2] = 30;
//    arr[0][3] = 40;
//    
//    arr[1][0] = 100;
//    arr[1][1] = 200;
//    arr[1][2] = 300;
//    arr[1][3] = 400;
//    
//    
//    arr[2][0] = 1000;
//    arr[2][1] = 2000;
//    arr[2][2] = 3000;
//    arr[2][3] = 4000;
//    
    for(int i = 0; i < 3; i++)//外层循环控制行数.
    {
        for(int j = 0; j < 4; j++)
        {
            printf("%d\t",arr[i][j]);
        }
        printf("\n");
    }
    
    
   // printf("%d\n",arr[1][2]);
    
    

    return 0;
}
